import os
from shutil import copy2, move
import tkinter.messagebox
from tkinter.filedialog import askopenfilename, askopenfilenames, askdirectory
from tkinter.simpledialog import askstring
from datetime import datetime
import xxhash
from glob import glob

from settings import settings_read, settings_save_to_file, current, INSTALL_PATH, MODULES_LIBRARY, BACKUP_FOLDER, \
    MODULE_TEMPLATE
from constants import PROGRAM_NAME, InternalError, LOG_PATH


SNAPSHOT_DIRECTORY = './snapshots'
SNAPSHOT_COMPARISON_DIRECTORY = './snapshot_comparisons'
COMPARISON_NAME = 'comparison_'

TRANSFER_TYPES = [
    'move',
    'copy',
    'delete',
]
DEFINITION_NAME = '_definition.ini'
DEFINITION_CLASSES = ['General', 'Clone', 'Foundling', 'Template']  # 'Version', 'Module'
DEFINITION_CLASS_TEMPLATE = {
    'path': '',
    'class': '',
    'comment': "// do not edit this file by hand. Use the 'edit definition' option in the application\n",
    'game': '',
    'name': '',
    'active': False,
    'progress': '',
    'ancestor': '',
    'heir': '',
    'description': '',
    'changes': {}
}


# 024-08-06
class Definition(dict):
    """ A dictionary-based class with predefined keys and functions that manipulate modules. """
    def __init__(self):
        super().__init__()
        for key in DEFINITION_CLASS_TEMPLATE:
            try:
                self[key] = DEFINITION_CLASS_TEMPLATE[key].copy()
            except AttributeError:
                self[key] = DEFINITION_CLASS_TEMPLATE[key]

    def edit(self, **key_args):
        return definition_edit(self, **key_args)

    def retrieve(self):
        # if self['class'] == DEFINITION_CLASSES[0]:
        try:
            module_reverse(module_object=self, transfer='remove')
            return True
        except InternalError:
            return False

    def attach(self):
        try:
            module_attach(self)
            return True
        except InternalError:
            try:
                module_attach(module_directory=f"{current(MODULES_LIBRARY)}/{self['name']}")
                return True
            except InternalError:
                module_attach(module_directory=self['path'])
                return True

    def reload(self):
        # if self['class'] == DEFINITION_CLASSES[0]:
        if self.retrieve():
            if self.attach():
                return True
            else:
                return False
        else:
            return False

    def reload_after_class_change(self):
        if self['class'] == DEFINITION_CLASSES[0]:
            module_reverse(self, transfer='delete', check_type='pass')
            module_attach(self)
        if self['class'] == DEFINITION_CLASSES[1]:
            module_reverse(self, transfer='copy', check_type='pass')
            module_attach(self)

    def extract(self):
        module_reverse(module_object=self, transfer='copy')


DEFINITION_EXAMPLE = Definition()
print_colors = {
    'information': '\033[96m',
    'warning': '\033[93m',
    'error': '\033[91m',
    'end': '\033[0m',
}


# 024-08-30
def log(output):
    """ Saves the given text into the main change log. """
    text = ''
    if TEST:
        for importance_level in print_colors[:-1]:
            if importance_level in output:
                text = (output[:output.index(importance_level)] + print_colors[importance_level] + importance_level
                        + print_colors['end'] + output[output.index(importance_level) + len(importance_level):])
        if text:
            print(text)
        else:
            print(output)
    else:
        date = str(datetime.now()) + '\t'
        if not os.path.isdir(LOG_PATH):
            os.mkdir(LOG_PATH)
        try:
            with open(f'{LOG_PATH}/main_change_log.txt', 'a') as log_buffer:
                log_buffer.write(date + output + '\n')
        except FileNotFoundError:
            with open(f'{LOG_PATH}/main_change_log.txt', 'w') as log_buffer:
                log_buffer.write(date + output + '\n')
    return output


def library_exceptions():
    """ Reads the library exceptions from the settings and returns a list of them. """
    settings = settings_read()
    exception_folders = []
    for folder in settings['LibraryExceptions']:
        if isinstance(folder, dict):
            exception_folders.append(folder['LibraryException'].replace('\\', '/'))
        elif isinstance(folder, str):
            exception_folders.append(folder.replace('\\', '/'))
    try:
        exception_folders.append(current(MODULE_TEMPLATE))
    except InternalError:
        pass
    return exception_folders


def game_names():
    """ Reads the game paths from the settings and returns a list of them. """
    settings = settings_read()
    game_names_list = []
    for directory in settings['GamePaths']:
        if 'aotr'.upper() in directory.upper():
            game_names_list.append('/'.join(directory.replace('\\', '/').split('/')[-2:]))
        else:
            game_names_list.append(directory.replace('\\', '/').split('/')[-1])
    return game_names_list


# 024-08-06
def definition_write(definition_object=None, module_directory=None, return_type='object', changes_source=None,
                     **key_args):
    """
    Reads a definition and formats it into text, that can be saved into a text file.
    :param definition_object: (optional) a definition dictionary-like object
    :param module_directory: (optional) a path to identify a module and to save the definition to
    :param return_type: 'object' (+) 'save' - if 'object', returns a definition dictionary-like object.
    If 'text save' or 'object save', saves the definition into a file.
    :param changes_source: (optional) 'directory' | 'snapshot' | 'comparison' | >the directory to base it upon<
    - passed to initiate_comparison
    :param key_args: (optional) key - arguments pairs for values to change before saving.
    :return: according to the return_type
    """
    if module_directory is None:
        if definition_object is None:
            module_directory = askdirectory(title=f'{PROGRAM_NAME}: select the directory to define as a module',
                                            initialdir=current(MODULES_LIBRARY))
            if not module_directory:
                raise InternalError('write_definition: directory not selected')
        elif os.path.isdir(f"{current(MODULES_LIBRARY)}/{definition_object['name']}"):
            module_directory = f"{current(MODULES_LIBRARY)}/{definition_object['name']}"
    if definition_object is not None:
        module_name = definition_object['name']
    elif module_directory is not None:
        module_name = module_directory.split('/')[-1]
    else:
        module_name = 'default name'
    if definition_object is None:
        if os.path.isfile(f'{module_directory}/{DEFINITION_NAME}'):
            definition_object = definition_read(module_path=f'{module_directory}')
        else:
            definition_object = Definition()
    else:
        pass
    definition_text = definition_object['comment']
    if 'class' in key_args:
        definition_text += f"{key_args['class']} {module_directory.split('/')[-1]}\n"
        pass
    elif definition_object['class'] and definition_object['name']:
        definition_text += f"{definition_object['class']} {definition_object['name']}\n"
        pass
    else:
        definition_object['class'] = DEFINITION_CLASSES[0]
        definition_object['name'] = module_directory.split('/')[-1]
        definition_text += f"{DEFINITION_CLASSES[0]} {module_directory.split('/')[-1]}\n"
    try:
        if not definition_object['game'] and os.path.isdir(module_directory):
            game_folders = os.listdir(module_directory)
            for folder in game_folders:
                if os.path.isdir(f'../{folder}'):
                    definition_object['game'] = folder
                    break
            if not definition_object['game']:
                definition_object['game'] = module_name.split('-')[0]
    except IndexError:
        pass
    if not definition_object['path'] and module_directory:
        definition_object['path'] = os.path.relpath(module_directory).replace('\\', '/')
    if not definition_object['name'] and module_directory:
        definition_object['name'] = module_directory.split('/')[-1]
    if 'ancestor' in key_args:
        definition_object['ancestor'] = key_args['ancestor']
    if 'heir' in key_args:
        definition_object['heir'] = key_args['heir']
    if not definition_object['changes']:
        try:
            if changes_source is None:
                changes_source = 'directory'
            definition_object['active'], initial_changes = initiate_comparison(module_directory, start_module=None,
                                                                               changes_source=changes_source)
        except InternalError:
            initial_changes = ''
    for key in DEFINITION_EXAMPLE:
        if key == 'comment' or key == 'class':
            pass
        elif key == 'changes':
            text_changes = ''
            if definition_object['changes']:
                changes_dict = definition_object['changes']
                for change_file in changes_dict:
                    text_changes += '\t\t' + change_file.replace('\\', '/') + f'\t{changes_dict[change_file]}\n'
            else:
                text_changes = initial_changes
            definition_text += f'\t{key}\n{text_changes}\tEnd\n'
        else:
            definition_text += f'\t{key} = {definition_object[key]}\n'
    definition_text += 'End'
    if 'save' in return_type:
        with open(f'{module_directory}/{DEFINITION_NAME}', 'w') as definition_buffer:
            definition_buffer.write(definition_text)
            log(f'definition saved in {module_directory}')
    if 'text' in return_type:
        return definition_text
    elif 'object' in return_type:
        return definition_object


# 024-08-06
def definition_read(definition_object=None, definition_text=None, module_name=None, module_path=None):
    """
    Reads the definition of an object and loads it into a dictionary.
    :param definition_object: (optional) a definition dictionary-like class
    :param definition_text: (optional) a definition text or definition file content
    :param module_name: (optional) a module name to look for and check if a definition file exists
    :param module_path: (optional) a module path to check if a definition file exists
    :return: a definition dictionary-like class
    """
    definition_lines = None
    if not module_path and module_name and os.path.isdir(f'{current(MODULES_LIBRARY)}/{module_name}'):
        module_path = f'{current(MODULES_LIBRARY)}/{module_name}'
    if module_path is not None:
        if module_path in library_exceptions():
            return DEFINITION_EXAMPLE
    if definition_text is None:
        if definition_object is Definition:
            module_path = definition_object['path']
        elif module_path is None or not module_path:
            definition_object = Definition()
            module_path = askdirectory(title=f'{PROGRAM_NAME}: select the module directory',
                                       initialdir=current(MODULES_LIBRARY))
            if not module_path:
                raise InternalError('read_definition: directory not selected')
        if definition_object is not None and os.path.exists(f'{module_path}/{DEFINITION_NAME}'):
            definition_object['path'] = os.path.relpath(module_path).replace('\\', '/')
        if os.path.exists(f'{module_path}/{DEFINITION_NAME}'):
            with open(f'{module_path}/{DEFINITION_NAME}') as definition_buffer:
                definition_lines = definition_buffer.readlines()
    elif isinstance(definition_text, str):
        definition_lines = definition_text.split('\n')
    if definition_object is None:
        definition_object = Definition()
    if definition_lines:
        for line in definition_lines:
            if line.startswith('//'):
                definition_object['comment'] = f'{line.strip()}\n'
            elif ' = ' in line.strip():
                parameter, value = line.strip().split(' = ')
                if parameter in DEFINITION_EXAMPLE:
                    if value == 'True':
                        definition_object[parameter] = True
                    elif value == 'False':
                        definition_object[parameter] = False
                    else:
                        definition_object[parameter] = value
            elif '\t' in line.strip():
                # try:
                file_path, vector = line.strip().split('\t')
                definition_object['changes'][file_path] = vector
                # except:
                #     pass
            elif line.split()[0] in DEFINITION_CLASSES:
                definition_object['class'] = line.split()[0]
    else:
        do_initiate = tkinter.messagebox.askokcancel(
            title=PROGRAM_NAME,
            message=f'The potential module {module_path}\n seems to have no definition.\n'
                    'Do you wish for an automatic definition to be created?\n'
        )
        if do_initiate:
            try:
                definition_object = definition_write(module_directory=module_path, return_type='object save')
            except InternalError:
                raise InternalError('Settings not loaded, saving aborted')
        else:
            # EXCEPTION_FOLDERS.append(module_path)
            settings_save_to_file(LibraryExceptions=module_path)
    return definition_object


# 024-08-06
def definition_edit(definition_object=None, module_path=None, **key_args):
    """
    Edits parameters of a Definition object
    :param definition_object: (optional) a Definition object to edit
    :param module_path: (optional) the path to a module with a definition file.
    :param key_args: key - arguments pairs of parameters to changes.
    :return: the edited Definition object.
    """
    if definition_object is None:
        if module_path is None:
            module_path = askdirectory(title=f'{PROGRAM_NAME}: select the module directory',
                                       initialdir=current(MODULES_LIBRARY))
        if module_path:
            definition_object = definition_read(module_path=module_path)
        if not definition_object:
            raise InternalError('definition_edit: definition missing')
    else:
        if module_path is None:
            module_path = f"{current(MODULES_LIBRARY)}/{definition_object['name']}"
    for key in key_args:
        if key in DEFINITION_EXAMPLE:
            if key == 'name':
                list_modules = modules_filter(return_type='names')
                for module_name in list_modules:
                    if key_args['name'] == module_name:
                        raise InternalError('definition_edit: name already in use')
                for module_name in list_modules:
                    module_definition = definition_read(module_path=f'{current(MODULES_LIBRARY)}/{module_name}')
                    if definition_object['name'] in module_definition['ancestor']:
                        definition_edit(
                            module_definition,
                            ancestor=module_definition['ancestor'].replace(definition_object['name'], key_args['name'])
                        )
                    if definition_object['name'] in module_definition['heir']:
                        definition_edit(
                            module_definition,
                            heir=module_definition['heir'].replace(definition_object['name'], key_args['name'])
                        )
                os.rename(src=module_path, dst=f"{'/'.join(module_path.split('/')[:-1])}/{key_args['name']}")
            definition_object[key] = key_args[key]
        else:
            print(f'key {key} not recognized')
    # log(f'definition edited in {module_path}')
    return definition_write(definition_object, return_type='object save')


# 024-10-08
def detect_new_modules():
    output = ''
    library_folders = [_ for _ in os.listdir(current(MODULES_LIBRARY)) if _ not in library_exceptions()]
    for folder in library_folders:
        if not os.path.isfile(f'{current(MODULES_LIBRARY)}/{folder}/{DEFINITION_NAME}'):
            output += f'Registering a definition-less folder in the library - {folder}\n'
    return output


# 024-07-30
def hash_file(file_path):
    """ Returns the hash value of a file. Non-cryptographic 128 hexadecimal hash value. """
    with open(file_path, 'rb') as file_buffer:
        file_content = file_buffer.read()
    hash_value = xxhash.xxh128(file_content).hexdigest()
    return hash_value


# 024-07-29
def hash_directory(file_or_folder, path_to_omit=''):
    """ Composes a text where every file of a given directory is listed with its hash value. """
    output = ''
    if os.path.isfile(file_or_folder):
        if path_to_omit:
            path_to_register = file_or_folder[file_or_folder.index(path_to_omit) + len(path_to_omit) + 1:]
        else:
            path_to_register = file_or_folder
        output += os.path.relpath(path_to_register).replace('\\', '/') + f'\t{hash_file(file_or_folder)}\n'
    elif os.path.isdir(file_or_folder):
        next_directory = os.listdir(file_or_folder)
        for next_folder in next_directory:
            if next_folder in game_names():
                next_directory = [next_folder]
                break
        for next_file_or_folder in next_directory:
            output += hash_directory(f'{file_or_folder}/{next_file_or_folder}', path_to_omit=path_to_omit)
    return output


def get_available_name(snapshot_directory, prefix='file_snapshot_'):
    """ Given a directory, returns the name of the next file to save into. """
    counter = 1
    if not os.path.isdir(snapshot_directory):
        os.mkdir(snapshot_directory)
    elif os.path.exists(f'{snapshot_directory}/{prefix}{counter}.txt'):
        snapshot_list = glob(f'{snapshot_directory}/{prefix}*.txt')
    try:
        suffix = ''
        while not suffix.isnumeric():
            last_snapshot = max(snapshot_list, key=os.path.getctime)
            snapshot_list.remove(last_snapshot)
            suffix = last_snapshot[last_snapshot.index(prefix) + len(prefix):last_snapshot.index('.txt')]
        counter = str(int(suffix) + 1)
    except ValueError:
        counter = askstring(title=f'{PROGRAM_NAME}', prompt='Please give a name to the new file')
    except NameError:
        pass
    return f'{snapshot_directory}/{prefix}{counter}.txt'


# 024-07-30
def snapshot_take(game_paths=None, add_paths=False, return_type='path', name=None):
    """
    Takes a snapshot of a selected directory.
    :param game_paths: directory to take a snapshot of.
    :param add_paths: True | False - when True, asks for new directories until cancel is pressed.
    :param return_type: 'path' | 'text' (+) 'save' - if 'path', returns the path of the file where the snapshot has been saved.
    If 'text', returns the content.
    :param name:
    :return: according to return-type.
    """
    if game_paths is None:
        game_paths = ['>no_path<']
    game_snapshot = str(datetime.now()) + '\n'
    path_to_omit = ''
    for game_path in game_paths:
        if game_path == '>no_path<':
            game_full_path = askdirectory(initialdir=f'{current(INSTALL_PATH)}',
                                          title=f'{PROGRAM_NAME}: select game directory to take a snapshot of')
            if game_full_path:
                if current(MODULES_LIBRARY) in game_full_path:
                    path_to_omit += '/'.join(game_full_path.split('/')[:current(MODULES_LIBRARY).count('/') + 2])
                path_to_omit_locally = current(INSTALL_PATH)
                # game_path = game_full_path[game_full_path.index(path_to_omit_locally) + len(path_to_omit_locally) +1:]
                game_path = game_full_path[len(path_to_omit_locally):]
                game_paths[game_paths.index('>no_path<')] = game_path
                if add_paths:
                    game_paths.append('>no_path<')
            elif len(game_paths) == 0:
                raise InternalError('snapshot_take: directory not selected')
        mod_dir = f'{current(INSTALL_PATH)}/{game_path}'
        if not os.path.isdir(mod_dir):
            game_paths.remove(game_path)
    for game_path in game_paths:
        if not game_path:
            raise InternalError('snapshot_take: directory not selected')
        game_snapshot += hash_directory(f'{current(INSTALL_PATH)}/{game_path}', path_to_omit=path_to_omit)
    if game_snapshot.count('\n') <= 1:
        raise InternalError('snapshot_take: directory not selected')
    if return_type == 'text':
        log('snapshot_take successful')
        return game_snapshot
    if not name:
        snapshot_path = get_available_name(SNAPSHOT_DIRECTORY)
    elif os.path.isfile(f'{SNAPSHOT_DIRECTORY}/{name}.txt'):
        snapshot_path = f'{SNAPSHOT_DIRECTORY}/{name}-datetime.date().txt'
    else:
        snapshot_path = f'{SNAPSHOT_DIRECTORY}/{name}.txt'
    with open(snapshot_path, 'w') as snapshot_buffer:
        snapshot_buffer.write(game_snapshot)
    log(f'snapshot successfully saved in file {snapshot_path}')
    if 'text' in return_type:
        return game_snapshot
    elif 'path' in return_type:
        return snapshot_path


# 024-07-30
def snapshot_compare(snap_anterior=None, snap_posterior=None, return_type='path'):
    """
    Compares two snapshots, determining which files are different, unchanged, new or removed.
    :param snap_anterior: first snapshot to compare to
    :param snap_posterior: second snapshot to compare with
    :param return_type: 'path' | 'lines' - If 'path', returns the path of the file, where the comparison has been saved.
    If 'lines', does not save the result into a file, but returns it.
    :return: according to the return_type.
    """
    content_anterior = []
    content_posterior = []
    lines = []
    if snap_anterior is None:
        snap_anterior = askopenfilename(title=f'{PROGRAM_NAME}: choose the base snapshot to compare with',
                                        initialdir='./snapshots')
        if not snap_anterior:
            raise InternalError('snapshot_compare: no snapshot selected')
    if isinstance(snap_anterior, list):
        content_anterior = snap_anterior.copy()
        snap_anterior = 'unsaved output'
    elif os.path.isfile(snap_anterior):
        with open(snap_anterior) as file_anterior:
            content_anterior = file_anterior.readlines()
    if snap_posterior is None:
        snap_posterior = askopenfilename(title=f'{PROGRAM_NAME}: choose the second snapshot to compare',
                                         initialdir='./snapshots')
        if not snap_posterior:
            raise InternalError('snapshot_compare: no snapshot selected')
    if isinstance(snap_posterior, list):
        content_posterior = snap_posterior.copy()
        snap_posterior = 'unsaved output'
    elif os.path.isfile(snap_posterior):
        with open(snap_posterior) as file_posterior:
            content_posterior = file_posterior.readlines()
    dict_anterior = {}
    dict_posterior = {}
    for line_anterior in content_anterior:
        if line_anterior.startswith('20'):
            lines.append(f'{snap_anterior} {line_anterior}')
        elif '\t' in line_anterior:
            name_anterior, code_anterior = line_anterior.strip().split('\t')
            dict_anterior[name_anterior] = code_anterior
    for line_posterior in content_posterior:
        if line_posterior.startswith('20'):
            lines.append(f'{snap_posterior} {line_posterior}\n')
        elif '\t' in line_posterior:
            name_posterior, code_posterior = line_posterior.strip().split('\t')
            dict_posterior[name_posterior] = code_posterior
    for key_name_anterior in dict_anterior:
        try:
            if dict_anterior[key_name_anterior] == dict_posterior[key_name_anterior]:
                lines.append(key_name_anterior + f'\tunchanged\n')
            else:
                lines.append(key_name_anterior + f'\tdifferent\n')
        except KeyError:
            lines.append(key_name_anterior + f'\tremoved\n')
    for key_name_posterior in dict_posterior:
        if key_name_posterior not in dict_anterior:
            lines.append(key_name_posterior + f'\tnew\n')
    if return_type == 'lines':
        return lines
    else:
        comparison_path = get_available_name(SNAPSHOT_COMPARISON_DIRECTORY, COMPARISON_NAME)
        with open(comparison_path, 'w') as last_comparison:
            last_comparison.writelines(lines)
        log(f'snapshot comparison saved to {comparison_path}')
        return comparison_path


def initiate_comparison(module_directory, start_module=None, changes_source='directory'):
    """
    Creates a change list for a module definition, based on provided data.
    :param module_directory: path to the module, whose definition is being created
    :param start_module: path to the present game folder to base the change on
    :param changes_source: 'directory' | 'comparison' | 'snapshot' -
    If 'directory', bases the changes on a present game folder.
    If 'comparison', bases the changes on a comparison file.
    If 'snapshot', bases the changes on the difference between present files and files in the snapshot.
    :return: tuple(active, changes)
    """
    # if start_module is None and changes_source != 'comparison' and not os.path.isdir(changes_source):
    if start_module is None and changes_source == 'directory':
        start_module = askdirectory(title=f'{PROGRAM_NAME}: select the game directory to define the mod',
                                    initialdir='../')
    if os.path.isdir(module_directory):
        changes = ''
        active = False
        if os.path.isdir(changes_source):
            active = True
            snapshot_take(  # snap_path =
                game_paths=[changes_source.split('/')[-1]], return_type='path', name=changes_source.split('/')[-1])
            # try:
            #     os.rename(snap_path, f"{snap_path[:snap_path.rfind('_')]}_{module_directory.split('/')[-1]}.txt")
            # except FileExistsError:
            #     pass
            current_files = hash_directory(changes_source).split('\n')
            for new_file in current_files:
                if len(new_file) > 0:
                    file_path, value = new_file.strip().split('\t')
                    changes += f'\t\t{file_path}\tnew\n'
        elif changes_source == 'directory':
            new_files = hash_directory(module_directory, path_to_omit=f'{module_directory}').split('\n')
            if start_module and new_files[0]:
                active = False
                current_files = hash_directory(
                    start_module, path_to_omit=f'{start_module[:start_module.rfind("/")]}').split('\n')  #
                for new_file in new_files:
                    if len(new_file) > 0:
                        file_path, value = new_file.strip().split('\t')
                        is_file_new = True
                        for current_file in current_files:
                            if len(current_file) > 0:
                                current_file_path, current_value = current_file.strip().split('\t')
                                if file_path == current_file_path:
                                    # if current_value != value:
                                    changes += f'\t\t../{file_path}\tdifferent\n'
                                    is_file_new = False
                                    break
                        if is_file_new:
                            changes += f'\t\t../{file_path}\tnew\n'
            elif start_module and not new_files[0]:
                active = True
                current_files = hash_directory(start_module).split('\n')
                for new_file in current_files:
                    if len(new_file) > 0:
                        file_path, value = new_file.strip().split('\t')
                        changes += f'\t\t{file_path}\tnew\n'
            files_to_remove = askopenfilenames(title=f'{PROGRAM_NAME}: select files to remove', initialdir='../')
            for file_path in files_to_remove:
                changes += f'\t\t../{file_path}\tremove\n'
            snapshot_take(
                    game_paths=[module_directory], name=module_directory.split('/')[-1])
        elif changes_source == 'comparison':
            selected_comparison = askopenfilename(
                title=f'{PROGRAM_NAME}: select the snapshot comparison to define the mod',
                initialdir=f'./{SNAPSHOT_COMPARISON_DIRECTORY}')
            if os.path.isfile(selected_comparison):
                with open(selected_comparison) as comparison_buffer:
                    comparison_lines = comparison_buffer.readlines()
                for line in comparison_lines:
                    if '\t' in line:
                        if line.strip().split('\t')[1] != 'unchanged':
                            changes += f'\t\t{line.strip()}\n'
                active = True
            else:
                raise InternalError('comparison not selected')
        elif changes_source == 'snapshot':
            selected_snapshot = askopenfilename(
                title=f'{PROGRAM_NAME}: select the snapshot taken before the changes',
                initialdir=f'./{SNAPSHOT_DIRECTORY}')
            if os.path.isfile(selected_snapshot):
                with open(selected_snapshot) as snapshot_buffer:
                    snapshot_lines = snapshot_buffer.readlines()
                game_paths = []
                for line in snapshot_lines:
                    if '\t' in line.strip():
                        file_path, value = line.strip().split('\t')
                        # TODO later: universalize if different path
                        game_path = file_path.replace('\\', '/').split('/')[1]
                        if game_path not in game_paths:
                            game_paths.append(game_path)
                new_snapshot = snapshot_take(
                    game_paths=game_paths, return_type='text save', name=module_directory.split('/')[-1])
                comparison_lines = snapshot_compare(selected_snapshot, new_snapshot.split('\n'), return_type='lines')
                for line in comparison_lines:
                    if '\t' in line:
                        if line.strip().split('\t')[1] != 'unchanged':
                            changes += f'\t\t{line.strip()}\n'
                active = True
            else:
                raise InternalError('snapshot not selected')
        # if changes_source == 'directory':
        log(f'comparison generated for {module_directory}')
        return active, changes
    else:
        raise InternalError('provided directory is not correct')


test_previous_src = ''
test_previous_dst = ''
test_previous_type = ''
error_sensitivity = True


def test_transfer(src, dst='', transfer='copy', error_sensitive=True):
    """
    If TEST == True, reports if the file can be transferred, else tries to transfer the file from source to destination.
    :param src: path of the file to transfer
    :param dst: path of the directory to transfer to
    :param transfer: 'copy' | 'move' | 'delete' - transfer type.
    :param error_sensitive: if True, stops if an error is detected.
    :return: text gathering the report of the transfer.
    """
    global test_previous_src, test_previous_dst, test_previous_type, error_sensitivity
    output = ''
    if TEST:
        if os.path.exists(src):
            if transfer == 'delete':
                log(f'for deletion: {src}')
                if not os.path.isfile(f"{dst}/{src.split('/')[-1]}"):
                    log(f"warning: original absent {dst}/{src.split('/')[-1]}")
            else:
                log(f'source: {src}')
        else:
            log(f'error: source absent {src}')
        if dst and transfer != 'delete':
            if os.path.exists(dst):
                if os.path.isfile(f"{dst}/{src.split('/')[-1]}") and test_previous_src == f"{dst}/{src.split('/')[-1]}":
                    if test_previous_type == 'delete':
                        log(f'information: destination {test_previous_src} deleted')
                    elif test_previous_type == 'move':
                        log(f'destination: {dst} (correct)')
                    else:
                        log(f"warning: destination present {dst}/{src.split('/')[-1]}")
                else:
                    log(f'destination: {dst}')
            else:
                log(f'error: destination absent {dst}')
        test_previous_src, test_previous_dst, test_previous_type = src, dst, transfer
    else:
        try:
            if transfer == 'copy':
                copy2(src, dst)
            elif transfer == 'move':
                move(src, dst)
            elif transfer == 'delete':
                os.remove(src)
        except OSError as err:
            if src.endswith('.bak'):
                new_src = src.replace('.bak', '')
                return test_transfer(new_src, dst, transfer, error_sensitive)
            elif src.endswith('.disabled'):
                new_src = src.replace('.disabled', '.big')
                return test_transfer(new_src, dst, transfer, error_sensitive)
            elif src.endswith('.big'):
                new_src = f'{src}.bak'
                if os.path.isfile(new_src):
                    return test_transfer(new_src, dst, transfer, error_sensitive)
            # output += f'{err.strerror} as {err.filename}'
            if error_sensitive:
                # TODO later: own message box - a self-explanatory one
                do_proceed = tkinter.messagebox.askyesnocancel(
                    title=f'{PROGRAM_NAME}: error',
                    # message=f'{err}\nDo you want to proceed or to cancel the module transfer'
                    message=f'{err}\n Click "Yes" to continue displaying each error and to proceed.\n'
                    'Click "No" to skip all errors and to proceed.\n Click "Cancel" to stop and revert the changes made'
                )
                if do_proceed is True:
                    pass
                elif do_proceed is False:
                    error_sensitivity = False
                elif do_proceed is None:
                    raise InternalError(err)
    return output


def ensure_path_exists(file_path, check_path='..'):
    """ Creates the directories in the ARCHIVE and LIBRARY folders where the files will be transferred. """
    try:
        if not os.path.exists(check_path):
            os.mkdir(check_path)
    except FileNotFoundError:
        pass
    path_folders = file_path.split('/')
    file_path_part = ''
    for file_folder in path_folders[1:-1]:
        file_path_part += f'/{file_folder}'
        if not os.path.exists(f'{check_path}{file_path_part}'):
            os.mkdir(f'{check_path}{file_path_part}')


# 024-09-22
def check_library(module_object):
    changes = module_object['changes']
    library_missing = False
    for file in changes:
        if not os.path.isfile(file.replace('../', f"{current(MODULES_LIBRARY)}/{module_object['name']}/")):
            library_missing = True
    return library_missing


# 024-07-30
def module_reverse(module_object=None, module_name='', transfer='copy', comparison_path='', last_snapshot=None,
                   check_type='definition'):
    """
    Detaches the module from the game directory, by retrieving all its files to the LIBRARY.
    :param module_object: (optional) the dictionary-based Definition object
    :param module_name: (optional) the name of the module to detach
    :param transfer: 'copy' | 'move' | 'delete' - transfer type.
    :param comparison_path: (optional) path to a comparison file on which the changes will be based.
    :param last_snapshot: (optional) path to a snapshot file on which the changes will be based.
    :param check_type: 'definition' | 'snapshot' | 'pass' - check if the module is indeed in the game folder
    If 'definition', checks the files enlisted in the changes of the definition file.
     Also checks and detaches if necessary any modules depending on this one.
    If 'snapshot', checks the files compared to the values in a given snapshot file.
    If 'pass', does not check, just tries to detach what it can.
    :return: logs about the transfer details.
    """
    global error_sensitivity
    comparison_lines = []
    if module_object:
        module_name = module_object['name']
        changes = module_object['changes']
        for change_file in changes:
            comparison_lines.append(change_file.replace('\\', '/') + f'\t{changes[change_file]}\n')
    if not os.path.isdir(f'{current(MODULES_LIBRARY)}/{module_name}'):
        os.mkdir(f'{current(MODULES_LIBRARY)}/{module_name}')
    module_directory = f'{current(MODULES_LIBRARY)}/{module_name}'
    if os.path.isfile(f"{module_directory}/{COMPARISON_NAME}{module_name}.txt"):
        comparison_path = f"{module_directory}/{COMPARISON_NAME}{module_name}.txt"
    if transfer == 'remove':
        try:
            if module_object is None:
                module_object = definition_read(module_path=module_directory)
        except InternalError as error:
            raise error
        if module_object['active'] is False and check_type != 'pass':
            raise InternalError('deactivation of inactive module aborted')
        if module_object['class'] == DEFINITION_CLASSES[0]:
            transfer = 'move'
        elif module_object['class'] == DEFINITION_CLASSES[1] and check_library(module_object):
            transfer = 'move'
        elif module_object['class'] == DEFINITION_CLASSES[1]:
            transfer = 'delete'
    if transfer == 'move' or transfer == 'delete':
        try:
            override = module_detect_changes(module_directory=module_directory)
        except InternalError as error:
            raise error
        if override:
            raise InternalError('module_reverse: changes have been made to the module file')
            # TODO later: if changes, propose to save them
    if not comparison_path and not comparison_lines:
        if last_snapshot is None:
            selected_file = askopenfilename(title=f'{PROGRAM_NAME}: select a snapshot or a comparison file',
                                            initialdir=SNAPSHOT_DIRECTORY)
            if selected_file.split('/')[-1].startswith(COMPARISON_NAME):
                comparison_path = selected_file
            elif selected_file.split('/')[-1].startswith('file_snapshot_'):
                last_snapshot = selected_file
        if last_snapshot:
            new_snapshot = snapshot_take(return_type='text')
            comparison_lines = snapshot_compare(last_snapshot, new_snapshot, return_type='lines')
        if not comparison_path:
            raise InternalError('module_reverse: comparison missing')
    if os.path.isfile(comparison_path) and not comparison_lines:
        with open(comparison_path) as comparison_file:
            comparison_lines = comparison_file.readlines()
    if not comparison_lines:
        raise InternalError('module_reverse: comparison missing')

    error_sensitivity = True
    if check_type == 'snapshot':
        # TODO later: verify prerequisites by making a snapshot and comparing it
        pass
    elif check_type == 'definition':
        if os.path.isfile(f'{module_directory}/{DEFINITION_NAME}'):
            definition_dict = definition_read(module_path=module_directory)
            if definition_dict['heir']:
                heir_directory = f"{'/'.join(module_directory.split('/')[:-1])}/{definition_dict['heir']}"
                if os.path.isfile(f'{heir_directory}/{DEFINITION_NAME}'):
                    heir_definition_dict = definition_read(module_path=heir_directory)
                    if heir_definition_dict['active']:
                        # raise ModuleError(f"module_reverse error: heir module {definition_dict['heir']} still active")
                        module_reverse(module_name=heir_definition_dict['name'], transfer='remove')
    elif check_type == 'pass':
        error_sensitivity = False
    output = ''
    try:
        for line in comparison_lines:
            path_start = current(INSTALL_PATH).replace('\\', '/').count('/')
            file_path, value = line.strip().split('\t')
            file_path_game = '/'.join(file_path.split('/')[:-1])
            file_path_module = (f"{current(MODULES_LIBRARY)}/{module_name}/"
                                f"{'/'.join(file_path.split('/')[path_start:-1])}")
            file_path_archive = f"{current(BACKUP_FOLDER)}/{module_name}/{'/'.join(file_path.split('/')[path_start:])}"
            if value == 'unchanged':
                pass
            elif value == 'different':
                if transfer in TRANSFER_TYPES:  # transfer == 'copy' or transfer == 'move':
                    ensure_path_exists(file_path, f'{current(MODULES_LIBRARY)}/{module_name}')
                    output += test_transfer(file_path, file_path_module, transfer, error_sensitivity)
                if transfer == 'move' or transfer == 'delete':
                    ensure_path_exists(file_path, f'{current(BACKUP_FOLDER)}/{module_name}')
                    output += test_transfer(file_path_archive, file_path_game, 'move', error_sensitivity)
            elif value == 'new':
                ensure_path_exists(file_path, f'{current(MODULES_LIBRARY)}/{module_name}')
                try:
                    output += test_transfer(file_path, file_path_module, transfer, error_sensitivity)
                except FileExistsError:
                    pass
            elif value == 'removed':
                if transfer == 'move' or transfer == 'delete':
                    ensure_path_exists(file_path, f'{current(BACKUP_FOLDER)}/{module_name}')
                    output += test_transfer(file_path_archive, file_path_game, 'move', error_sensitivity)
                else:
                    pass
    except InternalError:
        return module_attach(module_directory=module_directory, check_type='pass')
    if TEST:
        raise InternalError('under TEST phase: module_reverse not applied')
    definition_edit(definition_object=module_object, active=False)
    return log(f'module_reverse {module_name}\n{output}')


# 024-07-31
def module_attach(module_object=None, module_directory=None, check_type='definition'):
    """
    Attaches a module to the game directory.
    :param module_object: (optional) dictionary-based module object
    :param module_directory: (optional) path of the module to attach
    :param check_type: 'definition' | 'snapshot' | 'pass' - check if the module is indeed in the LIBRARY folder
    If 'definition', checks the files enlisted in the changes of the definition file.
     Also checks and attaches if necessary any modules required to this one.
    If 'snapshot', checks the files compared to the values in a given snapshot file.
    If 'pass', does not check, just tries to attach what it can.
    :return: logs about the transfer details.
    """
    global error_sensitivity
    transfer = 'move'
    if module_object is None:
        if module_directory is None:
            module_directory = askdirectory(title=f'{PROGRAM_NAME}: select module directory',
                                            initialdir=current(MODULES_LIBRARY))
            if not module_directory:
                raise InternalError('module_attach: module directory missing')
        if os.path.isfile(f'{module_directory}/{DEFINITION_NAME}'):
            module_object = definition_read(module_path=module_directory)
    error_sensitivity = True
    if check_type == 'snapshot':
        # TODO later: verify prerequisites by making a snapshot and comparing it
        pass
    elif check_type == 'definition':
        if os.path.isdir(module_object['path']):
            module_directory = module_object['path']
        elif os.path.isdir(f"{current(MODULES_LIBRARY)}/{module_object['name']}"):
            module_directory = f"{current(MODULES_LIBRARY)}/{module_object['name']}"
        else:
            raise InternalError('path not recognized')
        if module_object['active'] is True and check_type != 'pass':
            raise InternalError('activation of active module aborted')
        if module_object['class'] == DEFINITION_CLASSES[0]:
            transfer = 'move'
        elif module_object['class'] == DEFINITION_CLASSES[1]:
            transfer = 'copy'
        if module_object['ancestor']:
            ancestor_directory = f"{'/'.join(module_directory.split('/')[:-1])}/{module_object['ancestor']}"
            if os.path.isfile(f'{ancestor_directory}/{DEFINITION_NAME}'):
                ancestor_definition_dict = definition_read(module_path=ancestor_directory)
                if not ancestor_definition_dict['active']:
                    module_attach(module_directory=ancestor_directory)
    elif check_type == 'pass':
        error_sensitivity = False
    module_name = module_directory.split('/')[-1]
    if not os.path.isdir(f'{current(BACKUP_FOLDER)}/{module_name}'):
        os.mkdir(f'{current(BACKUP_FOLDER)}/{module_name}')
    comparison_lines = []
    try:
        # changes = definition_read(module_path=module_directory)['changes']
        changes = module_object['changes']
        for change_file in changes:
            comparison_lines.append(change_file.replace('\\', '/') + f'\t{changes[change_file]}\n')
    except InternalError:
        pass
    if not comparison_lines and os.path.isfile(f"{module_directory}/{COMPARISON_NAME}{module_name}.txt"):
        with open(f"{module_directory}/{COMPARISON_NAME}{module_name}.txt") as comparison_buffer:
            comparison_lines = comparison_buffer.readlines()
    if comparison_lines:
        try:
            output = ''
            path_start = current(INSTALL_PATH).count('/')
            for line in comparison_lines:
                try:
                    file_path, value = line.strip().split('\t')
                except ValueError:
                    raise InternalError('module_attach: valueError')
                file_path_game = '/'.join(file_path.split('/')[:-1])
                file_path_archive = (f"{current(BACKUP_FOLDER)}/{module_name}/"
                                     f"{'/'.join(file_path.split('/')[path_start:-1])}")
                file_path_module = (f"{current(MODULES_LIBRARY)}/{module_name}/"
                                    f"{'/'.join(file_path.split('/')[path_start:])}")
                if value == 'unchanged':
                    pass
                elif value == 'different':
                    ensure_path_exists(file_path)
                    ensure_path_exists(file_path, f'{current(BACKUP_FOLDER)}/{module_name}')
                    output += test_transfer(file_path, file_path_archive, transfer, error_sensitivity)
                    output += test_transfer(file_path_module, file_path_game, transfer, error_sensitivity)
                elif value == 'new':
                    ensure_path_exists(file_path)
                    output += test_transfer(file_path_module, file_path_game, transfer, error_sensitivity)
                elif value == 'removed':
                    ensure_path_exists(file_path)
                    output += test_transfer(file_path, file_path_archive, transfer, error_sensitivity)
        except InternalError:
            return module_reverse(module_object=module_object, transfer='remove', check_type='pass')
    else:
        raise InternalError('module_attach: comparison missing')
    if TEST:
        raise InternalError('Test phase: module_attach not applied')
    definition_edit(definition_object=module_object, active=True)
    return log(f'module_attach {module_name}\n{output}')


def module_copy(new_name, template_directory=None, changes_source=None):
    """
    Copies modules files into a new directory.
    :param new_name: the name of the module to create
    :param template_directory: the path to the module to copy
    :param changes_source: 'snapshot' | 'comparison' | 'directory' - passes the value to definition_write
    :return: logs about the details of the transfer
    """
    try:
        if template_directory is None and current(MODULE_TEMPLATE):
            template_directory = current(MODULE_TEMPLATE)
    except InternalError:
        try:
            template_directory = askdirectory(
                title=f'{PROGRAM_NAME}: choose a module template to copy',
                initialdir=current(MODULES_LIBRARY)
            )
        except InternalError:
            template_directory = askdirectory(
                title=f'{PROGRAM_NAME}: choose a module template to copy',
                initialdir='../'
            )
    if not template_directory:
        # raise InternalError('template not selected')
        return 'module_copy error: template not selected'
    all_modules_names = modules_filter(return_type='names')  # game='all'
    if new_name in all_modules_names:
        # raise InternalError('module_copy: name already in use')
        return 'module_copy error: name already in use'
    # output = f'module_copy: {template_directory} to {new_name}'
    os.mkdir(f'{current(MODULES_LIBRARY)}/{new_name}')
    output = f'{new_name} created. \n'
    folders = []
    files = []
    items_list = os.listdir(template_directory)
    for item in items_list:
        if os.path.isdir(f'{template_directory}/{item}'):
            folders.append(f'{current(MODULES_LIBRARY)}/{new_name}/{item}')
            for next_item in os.listdir(f'{template_directory}/{item}'):
                items_list.append(f'{item}/{next_item}')
                if os.path.isdir(f'{template_directory}/{item}/{next_item}'):
                    folders.append(f'{current(MODULES_LIBRARY)}/{new_name}/{item}/{next_item}')
        elif os.path.isfile(f'{template_directory}/{item}'):
            files.append(item)
        else:
            output += f'warning: item {item} is neither a file nor folder \n'
    if not folders and not files:
        # copy_default(current(MODULES_LIBRARY))
        # return module_copy(new_name, template_directory)
        pass
    for folder in folders:
        if not os.path.isdir(folder):
            os.makedirs(folder)
            output += folder + '\n'
    for file in files:
        if file == DEFINITION_NAME:
            definition_write(module_directory=f'{current(MODULES_LIBRARY)}/{new_name}', return_type='save',
                             changes_source=changes_source)
            continue
        copied_file = f'{template_directory}/{file}'
        try:
            test_transfer(copied_file, f'{current(MODULES_LIBRARY)}/{new_name}/{file}', 'copy')
            output += f'{current(MODULES_LIBRARY)}/{new_name}/{file}\n'
        except FileNotFoundError:
            output += f'warning: {file} permission denied'
        except FileExistsError:
            output += f'warning: {file} FileNotFoundError'
    return log(output)


# 024-08-06
def module_detect_changes(module_directory=None):
    """ Inspects if the files of a module have been changed and returns a text where the changes are listed. """
    changes = ''
    comparison_lines = []
    if module_directory is None:
        # selected_file = askopenfilename(title='Lord of the mods: select a snapshot or a comparison file',
        #                                 initialdir=module_directory)
        module_directory = askdirectory(title=f'{PROGRAM_NAME}: select a module directory',
                                        initialdir=current(MODULES_LIBRARY))
        # TODO: lower the above code an indentation level when snapshot verification is working
        if not module_directory:
            raise InternalError('module_detect_changes error: no module selected')
        module_name = module_directory.split('/')[-1]
        if os.path.isfile(f"{module_directory}/file_snapshot_{module_name}"):
            last_snapshot_path = f"{module_directory}/file_snapshot_{module_name}"
        elif os.path.isfile(f"{SNAPSHOT_DIRECTORY}/file_snapshot_{module_name}"):
            last_snapshot_path = f"{SNAPSHOT_DIRECTORY}/file_snapshot_{module_name}"
        else:
            last_snapshot_path = askopenfilename(title=f"{PROGRAM_NAME}: please select the snapshot of {module_name}",
                                                 initialdir=SNAPSHOT_DIRECTORY)
        if os.path.isfile(last_snapshot_path):
            new_snapshot = snapshot_take(return_type='text')
            comparison_lines = snapshot_compare(last_snapshot_path, new_snapshot, return_type='lines')
        else:
            raise InternalError('no initial snapshot selected')
        if not comparison_lines:
            raise InternalError('module_detect_changes: no comparison')
    # TODO later: check if files inside the module have changed
    for line in comparison_lines:
        if '\t' in line:
            file_path, value = line.strip().split('\t')
            if value == 'unchanged':
                pass
            elif value == 'different':
                changes += line
            elif value == 'new':
                changes += line
            elif value == 'removed':
                changes += line
        else:
            log(line)
    return changes


def modules_filter(return_type='definitions', **criteria):
    """
    Filters the modules definitions by given criteria
    :param return_type: 'definitions' | 'names'
    :param criteria: key - argument pairs, where the keywords are Definition parameters to compare the value against
    :return: Definition objects or module names, according to the return_type.
    """
    game_modules_list = []
    try:
        modules_names = [_ for _ in os.listdir(current(MODULES_LIBRARY)) if _ not in library_exceptions()]
        for module_name in modules_names:
            module_definition = definition_read(module_path=f'{current(MODULES_LIBRARY)}/{module_name}')
            if (module_definition['class'] == DEFINITION_CLASSES[0]
                    or module_definition['class'] == DEFINITION_CLASSES[1]):
                if criteria:
                    for criteria_key in criteria:
                        if criteria_key in DEFINITION_EXAMPLE:
                            if module_definition[criteria_key] == criteria[criteria_key]:
                                if return_type == 'names':
                                    game_modules_list.append(module_name)
                                elif return_type == 'definitions':
                                    game_modules_list.append(module_definition)
                else:
                    if return_type == 'names':
                        game_modules_list.append(module_name)
                    elif return_type == 'definitions':
                        game_modules_list.append(module_definition)
    except InternalError:
        raise InternalError('module_control.modules_filter(): settings not loaded')
    return game_modules_list


# 024-08-14
def modules_sort(criteria='ancestor', modules=None):
    """
    Sorts the modules into a dictionary of modules names as keys and their parent as value
    :param criteria:
    :param modules:
    :return:
    """
    if modules is None:
        modules = modules_filter()
    if criteria == 'ancestor':
        sorted_dict = {}
        for module in modules:
            for mod in modules:
                if mod['name'] == module[criteria]:
                    sorted_dict[module['name']] = str(modules.index(mod))  # module['name']
                    break
        return sorted_dict
    else:
        raise InternalError(message='modules_sort: unrecognized criteria')


TEST = False
# TEST = True


_all_defined = [
    SNAPSHOT_DIRECTORY,
    SNAPSHOT_COMPARISON_DIRECTORY,
    COMPARISON_NAME,
    DEFINITION_NAME,
    DEFINITION_CLASSES,
    DEFINITION_CLASS_TEMPLATE,
    Definition,
    DEFINITION_EXAMPLE,
    log,
    library_exceptions,
    game_names,

    definition_write,
    definition_read,
    definition_edit,

    hash_file,
    hash_directory,
    get_available_name,
    snapshot_take,
    snapshot_compare,
    initiate_comparison,

    test_transfer,
    ensure_path_exists,
    check_library,
    module_reverse,
    module_attach,
    module_copy,
    module_detect_changes,
    modules_filter,
    modules_sort,

    TEST,
]
